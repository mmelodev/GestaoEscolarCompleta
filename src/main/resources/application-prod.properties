spring.application.name=plataforma

# Server Configuration (Diagnóstico para Railway/Cloudflare)
# ⚠️ IMPORTANTE: Railway define PORT automaticamente, mas precisamos garantir que está configurado
# Railway usa variável de ambiente PORT que será injetada aqui
server.port=${PORT:8080}
# Escutar em todas as interfaces (obrigatório para Railway)
server.address=0.0.0.0
# Timeout aumentado para evitar erro 520 do Cloudflare
server.tomcat.connection-timeout=20000
server.tomcat.keep-alive-timeout=20000
# Shutdown graceful
server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=30s

# Logging Configuration (Diagnóstico)
# Logging mais detalhado para identificar problemas
logging.level.root=INFO
logging.level.org.springframework.web=INFO
logging.level.org.springframework.boot.autoconfigure=INFO
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=WARN
# Log específico para diagnóstico de startup
logging.level.br.com.arirang.plataforma=INFO
# Log de requisições HTTP (útil para diagnóstico)
logging.level.org.springframework.web.servlet.DispatcherServlet=INFO
logging.level.org.springframework.web.filter=INFO
# Log de conexão com banco (diagnóstico de problemas de conexão)
logging.level.com.zaxxer.hikari=DEBUG
logging.level.com.zaxxer.hikari.HikariConfig=DEBUG
logging.level.org.springframework.jdbc=INFO
logging.level.org.springframework.jdbc.datasource=DEBUG

# Spring Boot Actuator Configuration (Health Checks e Diagnóstico)
# Endpoint de health check público (sem autenticação) para Railway/Cloudflare
management.endpoints.web.exposure.include=health,info
management.endpoint.health.show-details=when-authorized
management.endpoint.health.show-components=always
# Health check simples e rápido
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
# Path do health check
management.endpoints.web.base-path=/actuator
management.endpoint.health.group.liveness.include=livenessState
management.endpoint.health.group.readiness.include=readinessState,db,diskSpace
# Health check do banco de dados
management.health.db.enabled=true
# Timeout para health checks
management.endpoint.health.probes.readiness-timeout=10s
management.endpoint.health.probes.liveness-timeout=10s

# Database Configuration
# Suporte para Railway (MYSQL_URL) e configuração manual (DB_URL/DB_HOST)
# Prioridade: DB_URL > MYSQL_URL (processada por RailwayDatabaseConfig) > montagem de variáveis individuais
# Nota: MYSQL_URL do Railway vem no formato mysql://user:pass@host:port/db
# A RailwayDatabaseConfig detecta automaticamente MYSQL_URL e converte para formato JDBC
# Se MYSQL_URL não estiver disponível, usar DB_URL ou construir a partir de variáveis individuais
# URL: Prioridade: DB_URL > MYSQL_URL (processada por RailwayDatabaseConfig) > valores padrão
# Nota: Não usar variáveis MYSQL_* aqui para evitar erro de placeholder
# A RailwayDatabaseConfig processa MYSQL_URL e sobrescreve esta propriedade
# URL: Será sobrescrita por RailwayDatabaseConfig se MYSQL_URL estiver disponível
# Se MYSQL_URL não estiver disponível, usar DB_URL
# NOTA: RailwayDatabaseConfig SEMPRE define valores padrão ANTES de processar MYSQL_URL
# Então mesmo se MYSQL_URL não existir, valores padrão já estarão definidos
# URL com parâmetros para lidar com Railway "sleep" mode (autoReconnect)
spring.datasource.url=${DB_URL:jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME:railway}?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=America/Sao_Paulo&autoReconnect=true&failOverReadOnly=false&maxReconnects=3&initialTimeout=2}
# Usuário e senha: Se usar MYSQL_URL, serão extraídos automaticamente pela RailwayDatabaseConfig
# Se usar variáveis individuais (DB_*), configure-as no Railway
# Nota: RailwayDatabaseConfig sobrescreve estas propriedades quando MYSQL_URL está presente
spring.datasource.username=${DB_USERNAME:root}
# Password: RailwayDatabaseConfig preencherá automaticamente se MYSQL_URL existir
# Caso contrário, usar DB_PASSWORD se configurado, ou string vazia como padrão
# Usando sintaxe que permite valor vazio sem erro de placeholder
spring.datasource.password=${DB_PASSWORD:}
spring.datasource.driver-class-name=${DB_DRIVER:com.mysql.cj.jdbc.Driver}

# HikariCP Connection Pool Configuration (otimizado para Railway "sleep" mode)
# Railway Free Tier coloca serviços em "sleep" após ~15-30 min de inatividade
# Estas configurações garantem que conexões sejam validadas e recriadas após wake-up
spring.datasource.hikari.maximum-pool-size=5
spring.datasource.hikari.minimum-idle=1
# Timeout aumentado para dar tempo do MySQL acordar (Railway sleep mode)
# 60 segundos para dar tempo suficiente do MySQL acordar
spring.datasource.hikari.connection-timeout=60000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.validation-timeout=10000
# Remover conexões que ficaram idle por muito tempo (útil após sleep)
spring.datasource.hikari.leak-detection-threshold=60000
# Configurações adicionais para Railway sleep mode
# Aumentado para dar mais tempo ao banco acordar
spring.datasource.hikari.initialization-fail-timeout=60000
spring.datasource.hikari.keepalive-time=300000
# Logging detalhado do HikariCP para diagnóstico
logging.level.com.zaxxer.hikari=DEBUG
logging.level.com.zaxxer.hikari.HikariConfig=DEBUG

# JPA/Hibernate Configuration
# Em produção, usar validate após schema inicial estar criado
# Use update apenas na primeira execução, depois altere para validate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.open-in-view=false
# Dialeto MySQL (necessário para Hibernate funcionar corretamente)
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
# Otimizações de memória do Hibernate (valores mais conservadores)
spring.jpa.properties.hibernate.jdbc.batch_size=10
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true
spring.jpa.properties.hibernate.jdbc.fetch_size=25
spring.jpa.properties.hibernate.default_batch_fetch_size=10
# Desabilitar cache completamente (economiza memória significativa)
spring.jpa.properties.hibernate.cache.use_second_level_cache=false
spring.jpa.properties.hibernate.cache.use_query_cache=false
# Reduzir estatísticas e validações (economiza memória durante startup)
spring.jpa.properties.hibernate.generate_statistics=false
spring.jpa.properties.hibernate.check_nullability=false
# Otimizar metadados (menos memória para metadados de entidades)
spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults=false

# Thymeleaf Configuration
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
# Cache de templates em produção (reduz uso de memória)
spring.thymeleaf.cache=true

# JWT Configuration
# ⚠️ OBRIGATÓRIO: JWT_SECRET deve ser configurado via variável de ambiente em produção
# ⚠️ Mínimo: 32 caracteres (256 bits) para segurança adequada com HMAC-SHA256
# ⚠️ Recomendado: Use um gerador de secrets seguro (openssl, etc.)
# ⚠️ Exemplo: openssl rand -base64 32
jwt.secret=${JWT_SECRET}
jwt.expiration=${JWT_EXPIRATION:86400000}
jwt.secret.min-length=32

# Redis Configuration (opcional - apenas se CACHE_TYPE=redis)
# Se Redis não estiver disponível, configure spring.cache.type=simple acima
spring.data.redis.host=${REDIS_HOST:}
spring.data.redis.port=${REDIS_PORT:6379}
spring.data.redis.password=${REDIS_PASSWORD:}

# Cache Configuration
# Redis não está disponível por padrão no Railway
# Se CACHE_TYPE=simple (padrão), usa cache em memória sem Redis
# Se quiser usar Redis, configure CACHE_TYPE=redis e provisione Redis no Railway
# IMPORTANTE: Quando spring.cache.type=simple, desabilita autoconfiguração do Redis
# para evitar erros de conexão. Se você quiser usar Redis, configure CACHE_TYPE=redis
# e remova ou comente a linha spring.autoconfigure.exclude abaixo
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration
spring.cache.type=${CACHE_TYPE:simple}
app.cache.enabled=${CACHE_ENABLED:true}
app.cache.default-ttl=${CACHE_DEFAULT_TTL:PT5M}
app.cache.cache-null-values=${CACHE_ALLOW_NULL:false}
app.cache.key-prefix=${CACHE_KEY_PREFIX:plataforma::}

# Swagger Configuration (desabilitado em produção)
springdoc.swagger-ui.enabled=false

# Default Users Configuration
# ⚠️ CRÍTICO: Em produção, NUNCA use senhas padrão hardcoded!
# ⚠️ Se APP_DEFAULT_ADMIN_PASSWORD não estiver configurado, a criação automática de usuários será DESABILITADA
# ⚠️ Configure APP_DEFAULT_ADMIN_PASSWORD através de variável de ambiente no Railway/Render
# ⚠️ Use um gerenciador de senhas seguro para armazenar credenciais
app.default.admin.password=${APP_DEFAULT_ADMIN_PASSWORD:}
app.default.test.password=${APP_DEFAULT_TEST_PASSWORD:}

# CORS Configuration (Produção)
# ⚠️ OBRIGATÓRIO: Configure as origens permitidas para sua aplicação frontend
# Domínio configurado: institutoarirangedu.com.br
# Opção 1: Padrões de origem (permite variações de porta, subdomínios, etc.)
# Permite https://institutoarirangedu.com.br e https://www.institutoarirangedu.com.br
app.cors.allowed-origin-patterns=${CORS_ALLOWED_ORIGIN_PATTERNS:https://*.institutoarirangedu.com.br,https://institutoarirangedu.com.br}

# Opção 2: Origens específicas (mais restritivo)
# Configurado para aceitar o domínio principal e www
app.cors.allowed-origins=${CORS_ALLOWED_ORIGINS:https://institutoarirangedu.com.br,https://www.institutoarirangedu.com.br}

# File Upload Configuration
# Tamanho máximo do arquivo (em bytes) - padrão: 5MB
spring.servlet.multipart.max-file-size=5MB
spring.servlet.multipart.max-request-size=5MB

# Configurações de validação de upload
app.upload.max-file-size=${UPLOAD_MAX_FILE_SIZE:5242880}
app.upload.allowed-extensions=${UPLOAD_ALLOWED_EXTENSIONS:.jpg,.jpeg,.png,.gif,.webp}
app.upload.validate-image-content=${UPLOAD_VALIDATE_IMAGE_CONTENT:true}
app.upload.max-image-width=${UPLOAD_MAX_IMAGE_WIDTH:4096}
app.upload.max-image-height=${UPLOAD_MAX_IMAGE_HEIGHT:4096}